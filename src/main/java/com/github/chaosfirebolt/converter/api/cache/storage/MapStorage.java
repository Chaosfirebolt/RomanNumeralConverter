package com.github.chaosfirebolt.converter.api.cache.storage;

import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Map based storage implementation.
 *
 * @param <K> key type
 * @param <V> value type
 */
public class MapStorage<K, V> implements Storage<K, V> {

  private static final String KEY_ERROR = "Null key";
  private static final String VALUE_ERROR = "Null value";

  private final Map<K, V> map;

  private MapStorage(Supplier<Map<K, V>> mapFactory) {
    this.map = mapFactory.get();
  }

  /**
   * Lenient factory method. Does not create defensive copy of the map generated by the factory.
   *
   * @param mapFactory factory supply new instance of the underlying map
   * @param <K>        key type
   * @param <V>        value type
   * @return new map based storage
   */
  public static <K, V> MapStorage<K, V> lenient(Supplier<Map<K, V>> mapFactory) {
    return new MapStorage<>(mapFactory);
  }

  /**
   * Strict factory method. Creates a defensive copy of the map generated by the factory.
   *
   * @param mapFactory factory supply new instance of the underlying map
   * @param <K>        key type
   * @param <V>        value type
   * @return new map based storage
   */
  public static <K, V> MapStorage<K, V> strict(Supplier<Map<K, V>> mapFactory) {
    Supplier<Map<K, V>> defensiveCopyFactory = new DefensiveCopyMapFactory<>(mapFactory);
    return new MapStorage<>(defensiveCopyFactory);
  }

  @Override
  public void store(K key, V value) {
    map.putIfAbsent(Objects.requireNonNull(key, KEY_ERROR), Objects.requireNonNull(value, VALUE_ERROR));
  }

  @Override
  public Optional<V> retrieve(K key) {
    V storedValue = map.get(Objects.requireNonNull(key, KEY_ERROR));
    return Optional.ofNullable(storedValue);
  }

  @Override
  public V compute(K key, Computation<K, V> computation) {
    Objects.requireNonNull(key, KEY_ERROR);
    Function<K, V> adaptedFunction = Objects.requireNonNull(computation, "Null computation").unwrap();
    V value = map.computeIfAbsent(key, adaptedFunction);
    return Objects.requireNonNull(value, "Null computed value");
  }

  @Override
  public void remove(K key) {
    map.remove(Objects.requireNonNull(key, KEY_ERROR));
  }

  @Override
  public void clear() {
    map.clear();
  }
}
